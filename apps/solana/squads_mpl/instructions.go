// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package squads_mpl

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "SquadsMpl"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	// Creates a new multisig account
	Instruction_Create = ag_binary.TypeID([8]byte{24, 30, 200, 40, 5, 28, 7, 119})

	// The instruction to add a new member to the multisig.
	// Adds member/key to the multisig and reallocates space if neccessary
	// If the multisig needs to be reallocated, it must be prefunded with
	// enough lamports to cover the new size.
	Instruction_AddMember = ag_binary.TypeID([8]byte{13, 116, 123, 130, 126, 198, 57, 34})

	// The instruction to remove a member from the multisig
	Instruction_RemoveMember = ag_binary.TypeID([8]byte{171, 57, 231, 150, 167, 128, 18, 55})

	// The instruction to change the threshold of the multisig and simultaneously remove a member
	Instruction_RemoveMemberAndChangeThreshold = ag_binary.TypeID([8]byte{230, 97, 183, 248, 43, 190, 154, 29})

	// The instruction to change the threshold of the multisig and simultaneously add a member
	Instruction_AddMemberAndChangeThreshold = ag_binary.TypeID([8]byte{114, 213, 59, 47, 214, 157, 150, 170})

	// The instruction to change the threshold of the multisig
	Instruction_ChangeThreshold = ag_binary.TypeID([8]byte{146, 151, 213, 63, 121, 79, 9, 29})

	// instruction to increase the authority value tracked in the multisig
	// This is optional, as authorities are simply PDAs, however it may be helpful
	// to keep track of commonly used authorities in a UI.
	// This has no functional impact on the multisig or its functionality, but
	// can be used to track commonly used authorities (ie, vault 1, vault 2, etc.)
	Instruction_AddAuthority = ag_binary.TypeID([8]byte{229, 9, 106, 73, 91, 213, 109, 183})

	// Instruction to create a multisig transaction.
	// Each transaction is tied to a single authority, and must be specified when
	// creating the instruction below. authority 0 is reserved for internal
	// instructions, whereas authorities 1 or greater refer to a vault,
	// upgrade authority, or other.
	Instruction_CreateTransaction = ag_binary.TypeID([8]byte{227, 193, 53, 239, 55, 126, 112, 105})

	// Instruction to set the state of a transaction "active".
	// "active" transactions can then be signed off by multisig members
	Instruction_ActivateTransaction = ag_binary.TypeID([8]byte{56, 17, 0, 163, 135, 11, 135, 32})

	// Instruction to attach an instruction to a transaction.
	// Transactions must be in the "draft" status, and any
	// signer (aside from execution payer) specified in an instruction
	// must match the authority PDA specified during the transaction creation.
	Instruction_AddInstruction = ag_binary.TypeID([8]byte{11, 70, 136, 166, 202, 55, 246, 74})

	// Instruction to approve a transaction on behalf of a member.
	// The transaction must have an "active" status
	Instruction_ApproveTransaction = ag_binary.TypeID([8]byte{224, 39, 88, 181, 36, 59, 155, 122})

	// Instruction to reject a transaction.
	// The transaction must have an "active" status.
	Instruction_RejectTransaction = ag_binary.TypeID([8]byte{47, 141, 218, 192, 80, 97, 209, 116})

	// Instruction to cancel a transaction.
	// Transactions must be in the "executeReady" status.
	// Transaction will only be cancelled if the number of
	// cancellations reaches the threshold. A cancelled
	// transaction will no longer be able to be executed.
	Instruction_CancelTransaction = ag_binary.TypeID([8]byte{65, 191, 19, 127, 230, 26, 214, 142})

	// Instruction to execute a transaction.
	// Transaction status must be "executeReady", and the account list must match
	// the unique indexed accounts in the following manner:
	// [ix_1_account, ix_1_program_account, ix_1_remaining_account_1, ix_1_remaining_account_2, ...]
	//
	// Refer to the README for more information on how to construct the account list.
	Instruction_ExecuteTransaction = ag_binary.TypeID([8]byte{231, 173, 49, 91, 235, 24, 68, 19})

	// Instruction to sequentially execute attached instructions.
	// Instructions executed in this matter must be executed in order,
	// this may be helpful for processing large batch transfers.
	// This instruction can only be used for transactions with an authority
	// index of 1 or greater.
	//
	// NOTE - do not use this instruction if there is not total clarity around
	// potential side effects, as this instruction implies that the approved
	// transaction will be executed partially, and potentially spread out over
	// a period of time. This could introduce problems with state and failed
	// transactions. For example: a program invoked in one of these instructions
	// may be upgraded between executions and potentially leave one of the
	// necessary accounts in an invalid state.
	Instruction_ExecuteInstruction = ag_binary.TypeID([8]byte{48, 18, 40, 40, 75, 74, 147, 110})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_Create:
		return "Create"
	case Instruction_AddMember:
		return "AddMember"
	case Instruction_RemoveMember:
		return "RemoveMember"
	case Instruction_RemoveMemberAndChangeThreshold:
		return "RemoveMemberAndChangeThreshold"
	case Instruction_AddMemberAndChangeThreshold:
		return "AddMemberAndChangeThreshold"
	case Instruction_ChangeThreshold:
		return "ChangeThreshold"
	case Instruction_AddAuthority:
		return "AddAuthority"
	case Instruction_CreateTransaction:
		return "CreateTransaction"
	case Instruction_ActivateTransaction:
		return "ActivateTransaction"
	case Instruction_AddInstruction:
		return "AddInstruction"
	case Instruction_ApproveTransaction:
		return "ApproveTransaction"
	case Instruction_RejectTransaction:
		return "RejectTransaction"
	case Instruction_CancelTransaction:
		return "CancelTransaction"
	case Instruction_ExecuteTransaction:
		return "ExecuteTransaction"
	case Instruction_ExecuteInstruction:
		return "ExecuteInstruction"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"create", (*Create)(nil),
		},
		{
			"add_member", (*AddMember)(nil),
		},
		{
			"remove_member", (*RemoveMember)(nil),
		},
		{
			"remove_member_and_change_threshold", (*RemoveMemberAndChangeThreshold)(nil),
		},
		{
			"add_member_and_change_threshold", (*AddMemberAndChangeThreshold)(nil),
		},
		{
			"change_threshold", (*ChangeThreshold)(nil),
		},
		{
			"add_authority", (*AddAuthority)(nil),
		},
		{
			"create_transaction", (*CreateTransaction)(nil),
		},
		{
			"activate_transaction", (*ActivateTransaction)(nil),
		},
		{
			"add_instruction", (*AddInstruction)(nil),
		},
		{
			"approve_transaction", (*ApproveTransaction)(nil),
		},
		{
			"reject_transaction", (*RejectTransaction)(nil),
		},
		{
			"cancel_transaction", (*CancelTransaction)(nil),
		},
		{
			"execute_transaction", (*ExecuteTransaction)(nil),
		},
		{
			"execute_instruction", (*ExecuteInstruction)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
